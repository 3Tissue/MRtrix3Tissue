#!/usr/bin/env python

# Script for checking the orientation of the diffusion gradient table

import copy, decimal, numbers, os, sys
import lib.app

from lib.binaryInPath   import binaryInPath
from lib.delFile        import delFile
from lib.errorMessage   import errorMessage
from lib.getHeaderInfo  import getHeaderInfo
from lib.getTrackStat   import getTrackStat
from lib.printMessage   import printMessage
from lib.runCommand     import runCommand
from lib.warnMessage    import warnMessage

lib.app.author = 'Robert E. Smith (robert.smith@florey.edu.au)'
lib.app.initCitations(['Jeurissen2014'])
lib.app.initParser('Check the orientation of the diffusion gradient table')
lib.app.parser.add_argument('input', help='The input DWI series to be checked')
lib.app.parser.add_argument('-mask', help='Provide a brain mask image')
lib.app.parser.add_argument('-number', type=int, default=10000, help='Set the number of tracks to generate for each test')
grad_import = lib.app.parser.add_mutually_exclusive_group()
grad_import.add_argument('-grad', help='Provide a gradient table in MRtrix format')
grad_import.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Provide a gradient table in FSL bvecs/bvals format')
grad_export = lib.app.parser.add_mutually_exclusive_group()
grad_export.add_argument('-export_grad_mrtrix', metavar='grad', help='Export the final gradient table in MRtrix format')
grad_export.add_argument('-export_grad_fsl', nargs=2, metavar=('bvecs', 'bvals'), help='Export the final gradient table in FSL bvecs/bvals format')
lib.app.initialise()

image_dimensions = [ int(i) for i in getHeaderInfo(lib.app.args.input, 'size').split() ]
if len(image_dimensions) != 4:
  errorMessage('Input image must be a 4D image')
num_volumes = image_dimensions[3]

# Make sure the image data can be memory-mapped
runCommand('mrconvert ' + lib.app.args.input + ' ' + os.path.join(lib.app.tempDir, 'data.mif') + ' -stride 0,0,0,1 -datatype float32')

if lib.app.args.grad:
  os.copy(lib.app.args.grad, os.path.join(lib.app.tempDir, 'grad.b'))
elif lib.app.args.fslgrad:
  os.copy(lib.app.args.fslgrad[0], os.path.join(lib.app.tempDir, 'bvecs'))
  os.copy(lib.app.args.fslgrad[1], os.path.join(lib.app.tempDir, 'bvals'))
if lib.app.args.mask:
  runCommand('mrconvert ' + lib.app.args.mask + ' ' + os.path.join(lib.app.tempDir, 'mask.mif') + ' -datatype bit')

lib.app.gotoTempDir()



# Make sure we have gradient table stored externally to header in both MRtrix and FSL formats
if not os.path.isfile('grad.b'):
  if os.path.isfile('bvecs'):
    runCommand('mrinfo data.mif -fslgrad bvecs bvals -export_grad_mrtrix grad.b')
  else:
    runCommand('mrinfo data.mif -export_grad_mrtrix grad.b')

if not os.path.isfile('bvecs'):
  if os.path.isfile('grad.b'):
    runCommand('mrinfo data.mif -grad grad.b -export_grad_fsl bvecs bvals')
  else:
    runCommand('mrinfo data.mif -export_grad_fsl bvecs bvals')

# Import both of these into local memory
with open('grad.b', 'r') as f:
  grad_mrtrix = f.read().split('\n')
# Erase the empty last line if necessary
if len(grad_mrtrix[-1]) <= 1:
  grad_mrtrix.pop()
# Is our gradient table of the correct length?
if not len(grad_mrtrix) == num_volumes:
  errorMessage('Number of entries in gradient table does not match number of DWI volumes')
# Turn into a float matrix
grad_mrtrix = [ [ float(f) for f in line.split(',') ] for line in grad_mrtrix ]
  
# Generate a brain mask if we weren't provided with one
if not os.path.exists('mask.mif'):
  runCommand('dwi2mask data.mif mask.mif')

# How many tracks are we going to generate?
number_option = ' -number ' + str(lib.app.args.number)


# 
# TODO What variations of gradient errors can we conceive?
# * Have the gradients been defined with respect to image space rather than scanner space?
# * After conversion to gradients in image space, are they _then_ defined with respect to scanner space?
# * Has an axis been flipped? (none, 0, 1, 2)
# * Have axes been swapped? (012 021 102 120 201 210)
# * For both flips & swaps, it could occur in either scanner or image space...

# For now, let's focus on the flips & swaps in scanner space; other components can be added later



axis_flips = [ 'none', 0, 1, 2 ]
axis_permutations = [ ( 0, 1, 2 ), (0, 2, 1), (1, 0, 2), (1, 2, 0), (2, 0, 1), (2, 1, 0) ]


# Dictionary with multiple keys per value
lengths = {}

# Mean length when using unmodified gradient table
orig_meanlength = 0.0

for flip in axis_flips:
  for permutation in axis_permutations:
  
    grad = copy.copy(grad_mrtrix)
    
    # Don't do anything if there aren't any axis flips occurring (flip == 'none')
    if isinstance(flip, numbers.Number):
      multiplier = [ 1.0, 1.0, 1.0, 1.0 ]
      multiplier[flip] = -1.0
      grad = [ [ r*m for r,m in zip(row, multiplier) ] for row in grad ]
        
    grad = [ [ row[permutation[0]], row[permutation[1]], row[permutation[2]], row[3] ] for row in grad ]
    
    suffix = '_flip' + str(flip) + '_perm' + ''.join(str(item) for item in permutation)

    # Create the gradient table file
    grad_path = 'grad' + suffix + '.b'
    with open(grad_path, 'w') as f:
      for line in grad:
        f.write (','.join([str(v) for v in line]) + '\n')

    # Run the tracking experiment
    runCommand('tckgen -algorithm tensor_det data.mif -grad ' + grad_path + ' -seed_image mask.mif -mask mask.mif' + number_option + ' -minlength 0 -downsample 5 tracks' + suffix + '.tck')

    # Get the mean track length
    # Upgrage tckstats: Need access to individual parameters, like what is provided by mrstats
    meanlength = getTrackStat('tracks' + suffix + '.tck', 'mean')
    
    # Add to the database
    lengths[(flip,permutation)] = meanlength
    
    # If this is the unmodified gradient table, want to save it
    if flip == 'none' and permutation == [ 0, 1, 2 ]:
      orig_meanlength = meanlength



print ('Axis flipped    Axis permutations    Mean length')
for line in sorted(lengths, key=lengths.get):
  if isinstance(line[0], numbers.Number):
    flip_str = "{:4d}".format(line[0])
  else:
    flip_str = line[0]
  print (flip_str + '                ' + str(line[1]) + '           ' + "{:5.2f}".format(lengths[line]))



lib.app.complete()

