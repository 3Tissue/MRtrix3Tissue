#!/bin/bash

#Script for performing EPI distortion correction using FSL 5.0 tools topup and applytopup

#This script is only for the specific case where a single pair of reversed-phase-encode images have been acquired for estimating the inhomogeneity field (phase encode A>>P then P>>A), which is to be used subsequently to correct a volume series (DWI / fMRI) that has been acquired using A>>P phase-encode direction. If your acquisition is different or more complex, you will need to modify this script accordingly or make your own.

#Order of input arguments is:
# * Anterior-posterior image from reverse phase-encode pair
# * Posterior-anterior image from reverse phase-encode pair
# * Image series to be corrected; note that motion correction should be applied BEFORE this script
# * Name of output corrected image series

#The script will generate a temporary directory for all of its working files, and delete this directory on close

set -e

if [ -z "$FSLDIR" ]; then
  echo "Environment variable FSLDIR is not set; please run appropriate FSL configuration script"
  return 0
fi 

TOPUP_CONFIG_PATH="$FSLDIR/etc/flirtsch/b02b0.cnf"

if [ ! -f "$TOPUP_CONFIG_PATH" ]; then
  echo "Could not find necessary default config file for FSL's topup program"
  return 0
fi 

if [ command -v topup >/dev/null 2>&1 ]; then
  if [ command -v fsl5.0-topup >/dev/null 2>&1 ]; then
    echo "Could not find FSL program topup in path; make sure FSL 5.0 is installed"
    return 0
  else
    TOPUP_CMD="fsl5.0-topup"
  fi
else
  TOPUP_CMD="topup"
fi

if [ command -v applytopup >/dev/null 2>&1 ]; then
  if [ command -v fsl5.0-applytopup >/dev/null 2>&1 ]; then
    echo "Could not find FSL program applytopup in path; make sure FSL 5.0 is installed"
    return 0
  else
    APPLYTOPUP_CMD="fsl5.0-applytopup"
  fi
else
  APPLYTOPUP_CMD="applytopup"
fi


EXPECTED_ARGS=4
if [ $# -ne $EXPECTED_ARGS ]
then
  echo "Usage: revpe_distcorr {AP image} {PA image} {Image series} {Output image}"
  return 0
fi


# Generate a random string, and use it to create a new temporary directory
TEMP_DIR_PREFIX="revpe_distcorr_TEMP_"
RANDOM_STRING=`tr -dc "[:alpha:]" < /dev/urandom | head -c 8`
TEMP_DIR="$TEMP_DIR_PREFIX$RANDOM_STRING/"
while [ -d $TEMP_DIR ]; do
  RANDOM_STRING=`tr -dc "[:alpha:]" < /dev/urandom | head -c 8`
  TEMP_DIR="$TEMP_DIR_PREFIX$RANDOM_STRING/"
done

mkdir $TEMP_DIR
cd $TEMP_DIR

# Concatenate the reversed-phase-encode pair into a nifti image
mrconvert ../$1 ap.nii -stride +1,+2,+3 -quiet
mrconvert ../$2 pa.nii -stride +1,+2,+3 -quiet
mrcat ap.nii pa.nii pair.nii -axis 3 -quiet

# Construct a configuration file
echo $'0  1 0 0.1\n0 -1 0 0.1\n' > config.txt

# Perform the field estimation
$TOPUP_CMD --imain=pair.nii --datain=config.txt --out=field --config=$TOPUP_CONFIG_PATH

# Convert the image series into something that FSL can recognise
mrconvert ../$3 series_before.nii -stride +1,+2,+3,+4 -quiet

# Apply the warp field to the image series
$APPLYTOPUP_CMD --imain=series_before.nii --datain=config.txt --inindex=1 --topup=field --out=series_after.nii --method=jac

# Get the original strides from the volume series using mrinfo, so that the output image can have the same strides
STRIDES=`mrinfo ../$3 | grep "Data strides: "`
STRIDES=${STRIDES##*[ }
STRIDES=${STRIDES%% ]*}
STRIDES=${STRIDES// /,}

# Get the diffusion gradient encoding from the input image (if not present, mrinfo throws an error and grad.b will be empty)
set +e
mrinfo ../$3 -gradient grad.b > /dev/null 2>&1

# Convert the resulting volume to the output image, and re-insert the diffusion encoding if present
if [[ $(stat -c%s "grad.b") -ne "0" ]]; then
  mrconvert series_after.nii ../$4 -stride $STRIDES -grad grad.b -quiet
else
  mrconvert series_after.nii ../$4 -stride $STRIDES -quiet
fi

# Delete all working files
rm -f *.*
cd ../
rmdir $TEMP_DIR



