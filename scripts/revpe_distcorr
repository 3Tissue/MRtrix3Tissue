#!/usr/bin/python2

# Script for performing EPI distortion correction using FSL 5.0 tools topup and applytopup

# This script is only for the specific case where a single pair of reversed-phase-encode images have been acquired for estimating the inhomogeneity field (phase encode A>>P then P>>A), which is to be used subsequently to correct a volume series (DWI / fMRI) that has been acquired using A>>P phase-encode direction. If your acquisition is different or more complex, you will need to modify this script accordingly or make your own.

# Unlike the previous version of this script, this now uses FSL's eddy tool to perform motion & eddy current correction as well as susceptibility distortion correction for DWI. Therefore the input images to this script should be the images as they are received from the scanner i.e. it is no longer necessary to perform DWI motion correction before running this script. However, if it is an fMRI time series that is being processed, eddy is not applicable, so motion correction will need to be applied prior to this script, and this script is only responsible for the susceptibility distortion correction. (Perhaps down the track FMRIB will modify mcflirt to use the field output from topup...?)

# Order of input arguments is:
# * Anterior-posterior image from reverse phase-encode pair
# * Posterior-anterior image from reverse phase-encode pair
# * Image series to be corrected
# * Name of output corrected image series


import os, shutil, subprocess, sys

from lib.binaryInPath import binaryInPath
from lib.delTempDir   import delTempDir
from lib.errorMessage import errorMessage
from lib.getFSLSuffix import getFSLSuffix
from lib.loadOptions  import loadOptions
from lib.makeTempDir  import makeTempDir
from lib.printMessage import printMessage
from lib.runCommand   import runCommand
from lib.warnMessage  import warnMessage


num_args = 4

if len(sys.argv) < num_args+1:
  errorMessage('Usage: ' + os.path.basename(sys.argv[0]) + ' <AP image> <PA image> <Input image series> <Output image series>')

fsl_path = os.environ.get('FSLDIR', '')
if not fsl_path:
  errorMessage('Environment variable FSLDIR is not set; please run appropriate FSL configuration script')

topup_config_path = os.path.join(fsl_path, 'etc', 'flirtsch', 'b02b0.cnf')
if not os.path.isfile(topup_config_path):
  errorMessage('Could not find necessary default config file for FSL\'s topup program\n(expected location: ' + topup_config_path + ')')

topup_cmd = 'topup'
if not binaryInPath(topup_cmd):
  topup_cmd = 'fsl5.0-topup'
  if not binaryInPath(topup_cmd):
    errorMessage('Could not find FSL program topup; please verify FSL install')

applytopup_cmd = 'applytopup'
if not binaryInPath(applytopup_cmd):
  applytopup_cmd = 'fsl5.0-applytopup'
  if not binaryInPath(applytopup_cmd):
    errorMessage('Could not find FSL program applytopup; please verify FSL install')
    
eddy_cmd = 'eddy'
if not binaryInPath(eddy_cmd):
  eddy_cmd = 'fsl5.0-eddy'
  if not binaryInPath(eddy_cmd):
    errorMessage('Could not find FSL program eddy; please verify FSL install')

(quiet, verbose) = loadOptions(num_args)

fsl_suffix = getFSLSuffix()

working_dir = os.getcwd()
temp_dir = makeTempDir(verbose)


# Convert the input files and place in the temporary directory
runCommand('mrcat ' + sys.argv[1] + ' ' + sys.argv[2] + ' - -axis 3' + quiet + ' | mrconvert - ' + os.path.join(temp_dir, 'pair.nii') + ' -stride +1,+2,+3,+4' + quiet, verbose)
runCommand('mrconvert ' + sys.argv[3] + ' ' + os.path.join(temp_dir, 'series_before.nii') + ' -stride +1,+2,+3,+4' + quiet, verbose)

# Get the output of running mrinfo on the input series, for finding the data layout
mrinfo_command = 'mrinfo ' + sys.argv[3]
mrinfo_out_path = os.path.join(temp_dir, 'mrinfo_out_series.txt')
if verbose:
  printMessage('Running \'' + mrinfo_command + '\' (piping output to ' + mrinfo_out_path + ')')
with open(mrinfo_out_path, 'w') as mrinfo_out:
  subprocess.call(mrinfo_command, stdout=mrinfo_out, stderr=None, shell=True)
  mrinfo_out.close()

# Also try to get the gradient encoding
# Subprocess needed to be used explicitly here as if there is no diffusion encoding, dwgradextract returns a fail code, terminating the script if runCommand() is used
dwgradextract_command = 'dwgradextract ' + sys.argv[3] + ' ' + os.path.join(temp_dir, 'bvecs') + ' -fsl' + quiet
if verbose:
  printMessage('Running \'' + dwgradextract_command + '\'')
dwgradextract_process = subprocess.call(dwgradextract_command, stdout=None, stderr=None, shell=True)

# Move into the temporary directory now that all files are prepared
if verbose:
  printMessage('Changing to temporary directory (' + temp_dir + ')')
os.chdir(temp_dir)

# Get the data layout of the original image series if possible
mrinfo_output = open ('mrinfo_out_series.txt', 'r')
stride_option = ''
for line in mrinfo_output:
  line = line.strip(' ')
  if line.startswith('Data strides: '):
    line = line[line.find("[")+2:line.find("]")-1]
    line = line.replace(' ', ',')
    stride_option = ' -stride ' + line
    if verbose:
      printMessage('Target data layout for output image series: ' + line)
      
# Need to check the dimensions along the three spatial axes of the image pair
mrinfo_command = 'mrinfo pair.nii'
mrinfo_out_path = 'mrinfo_out_pair.txt'
if verbose:
  printMessage('Running \'' + mrinfo_command + '\' (piping output to ' + mrinfo_out_path + ')')
with open(mrinfo_out_path, 'w') as mrinfo_out:
  subprocess.call(mrinfo_command, stdout=mrinfo_out, stderr=None, shell=True)
  mrinfo_out.close()

# If no axes need to be cropped, use the original 4D volume with the image pair
# Otherwise, need to call mrcrop with the appropriate options, and pass the modified image to topup
topup_imain = 'pair.nii'
applytopup_imain = 'series_before.nii'

# For any non-even dimensions, crop the first voxel along that dimension
mrinfo_output = open ('mrinfo_out_pair.txt', 'r')
crop_option = ''
for line in mrinfo_output:
  line = line.strip()
  if line.startswith('Dimensions: '):
    line = line.split(':')
    line = line[1].split('x')
    for index in range(0, 3):
      line[index] = line[index].strip()
      dim = int(line[index])
      if dim%2:
        crop_option += ' -axis ' + str(index) + ' 1 ' + str(dim-1)

if crop_option:
  warnMessage('Input images contain at least one non-even dimension; cropping images for topup / eddy compatibility') 
  runCommand('mrcrop pair.nii pair_crop.nii' + crop_option + quiet, verbose)
  runCommand('mrcrop series_before.nii series_crop.nii' + crop_option + quiet, verbose)
  topup_imain = 'pair_crop.nii'
  # Does the input image series also need to be cropped? Test this
  # It appears to be the case for eddy, not for applytopup; but just do it straight away
  applytopup_imain = 'series_crop.nii'

# Construct a configuration file
if verbose:
  printMessage('Creating phase-encoding configuration file')
config_file = open('config.txt', 'w')
config_file.write('0  1 0 0.1\n0 -1 0 0.1\n')
config_file.close()

# Perform the field estimation
runCommand(topup_cmd + ' --imain=' + topup_imain + ' --datain=config.txt --out=field --config=' + topup_config_path, verbose)

# Apply the warp field to the image series
# Note: applytopup appears to ignore FSLOUTPUTTYPE field, and just outputs a .nii.gz
runCommand(applytopup_cmd + ' --imain=' + applytopup_imain + ' --datain=config.txt --inindex=1 --topup=field --out=series_topup.' + fsl_suffix + ' --method=jac', verbose)

# Need to split depending on whether DW information is available
if os.path.exists('bvecs'):

  if verbose:
    printMessage('Detected diffusion gradient encoding in input file; running eddy')
    
  # Use the initial corrected image series from applytopup to derive a processing mask for eddy
  runCommand('mrconvert series_topup.' + fsl_suffix + ' -grad bvecs  -' + quiet + ' | dwi_brain_mask - -' + quiet + ' | mrdilate - - | mrconvert - mask.nii -datatype float32' + quiet, verbose)
  
  # Generate configuration file for eddy - index referring to PE and bandwidth for each volume
  # In this particular use case, we assume that every volume in the series has the same imaging parameters as the first of the reversed-PE pair
  # Therefore, every volume has an index of 1
  
  # Need to find the number of input volumes
  # For this, import bvals and count the number of entries
  bvals_input = open ('bvals', 'r')
  bvals = bvals_input.read()
  bvals = bvals.strip().split()
  num_volumes = len(bvals)
  
  indices = ''
  for volume in range(0, num_volumes):
    indices = indices + '1 '
  with open('indices.txt', 'w') as index_file:
    index_file.write(indices);
  
  # Run eddy
  fsl_verbose = ''
  if verbose:
    fsl_verbose = ' --verbose'
  runCommand('eddy --imain=' + applytopup_imain + ' --mask=mask.nii --index=indices.txt --acqp=config.txt --bvecs=bvecs --bvals=bvals --topup=field --out=series_after' + fsl_verbose, verbose)
  
  # Convert the resulting volume to the output image, and re-insert the diffusion encoding
  # Note that currently the script uses the diffusion encoding from the original DWI volumes, i.e. no reorientation of diffusion
  #   gradient vectors is performed. It should be possible to get the motion parameters from the eddy 
  # text file output and modify them manually, or FMRIB may update eddy itself.
  runCommand('mrconvert series_after.' + fsl_suffix + ' ' + os.path.basename(sys.argv[4]) + stride_option + ' -grad grad.b' + quiet, verbose) 
  
else: # No gradient encoding - input is fMRI time series
  if verbose:
    printMessage('No diffusion gradient encoding found in input file; using output from applytopup')
  runCommand('mrconvert series_topup.' + fsl_suffix + ' ' + os.path.basename(sys.argv[4]) + stride_option + quiet, verbose) 
  

# Move back to original directory
if verbose:
  printMessage('Changing back to original directory (' + working_dir + ')')
os.chdir(working_dir)

# Get the final file from the temporary directory & put it in the correct location
if verbose:
  printMessage('Moving output file from temporary directory to user specified location')
shutil.move(os.path.join(temp_dir, os.path.basename(sys.argv[4])), sys.argv[4])

# Don't leave a trace
delTempDir(temp_dir, verbose)

