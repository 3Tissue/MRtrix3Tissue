#!/bin/bash

#Script for performing EPI distortion correction using FSL 5.0 tools topup and applytopup

#This script is only for the specific case where a single pair of reversed-phase-encode images have been acquired for estimating the inhomogeneity field (phase encode A>>P then P>>A), which is to be used subsequently to correct a volume series (DWI / fMRI) that has been acquired using A>>P phase-encode direction. If your acquisition is different or more complex, you will need to modify this script accordingly or make your own.

#The script assumes that motion correction has already been applied to the image series. If this is not the case, then the corrections will be erroneous in the presence of significant motion.

#Order of input arguments is:
# * Anterior-posterior image from reverse phase-encode pair
# * Posterior-anterior image from reverse phase-encode pair
# * Image series to be corrected; note that motion correction should be applied BEFORE this script
# * Name of output corrected image series

#The script will generate a temporary directory for all of its working files, and delete this directory on close

set -e

if [ -z "$FSLDIR" ]; then
  echo "Environment variable FSLDIR is not set; please run appropriate FSL configuration script"
  return 0
fi 

TOPUP_CONFIG_PATH="$FSLDIR/etc/flirtsch/b02b0.cnf"

if [ ! -f "$TOPUP_CONFIG_PATH" ]; then
  echo "Could not find necessary default config file for FSL's topup program"
  return 0
fi 

if [ command -v topup >/dev/null 2>&1 ]; then
  if [ command -v fsl5.0-topup >/dev/null 2>&1 ]; then
    echo "Could not find FSL program topup in path; make sure FSL 5.0 is installed"
    return 0
  else
    TOPUP_CMD="fsl5.0-topup"
  fi
else
  TOPUP_CMD="topup"
fi

if [ command -v applytopup >/dev/null 2>&1 ]; then
  if [ command -v fsl5.0-applytopup >/dev/null 2>&1 ]; then
    echo "Could not find FSL program applytopup in path; make sure FSL 5.0 is installed"
    return 0
  else
    APPLYTOPUP_CMD="fsl5.0-applytopup"
  fi
else
  APPLYTOPUP_CMD="applytopup"
fi


FSLSUFFIX="nii.gz" # The default for FSL unless ${HOME}/.fslconf/fsl.sh is provided
if [ -z "$FSLOUTPUTTYPE" ]; then
  echo "Environment variable FSLOUTPUTTYPE not set; assuming compressed NIFTI"
  echo "(If the script runs into problems, you may need to manually set FSLOUTPUTTYPE)"
else
  case $FSLOUTPUTTYPE in
    "NIFTI")
    FSLSUFFIX="nii"
    ;;
    "NIFTI_PAIR")
    FSLSUFFIX="img"
    ;;
    "NIFTI_GZ")
    FSLSUFFIX="nii.gz"
    ;;
    "NIFTI_PAIR_GZ")
    echo "MRtrix does not currently support GZipped .hdr / .img pairs; please set environment variable FSLOUTPUTTYPE to something else"
    return 0
    ;;
    "*")
    echo "Environment variable FSLOUTPUTTYPE appears to not be supported by FSL; FSL may give an error"
    ;;
  esac
fi


EXPECTED_ARGS=4
if [ $# -ne $EXPECTED_ARGS ]
then
  echo "Usage: revpe_distcorr {AP image} {PA image} {Image series} {Output image}"
  return 0
fi


# Generate a random string, and use it to create a new temporary directory
TEMP_DIR_PREFIX="revpe_distcorr_TEMP_"
TEMP_DIR="."
while [ -d $TEMP_DIR ]; do
  RANDOM_STRING=`tr -dc "[:alpha:]" < /dev/urandom | head -c 8`
  TEMP_DIR="$TEMP_DIR_PREFIX$RANDOM_STRING/"
done

mkdir $TEMP_DIR
cd $TEMP_DIR

# Concatenate the reversed-phase-encode pair into a nifti image
mrconvert ../$1 ap.nii -stride +1,+2,+3 -quiet
mrconvert ../$2 pa.nii -stride +1,+2,+3 -quiet
mrcat ap.nii pa.nii pair.nii -axis 3 -quiet

# Construct a configuration file
echo $'0  1 0 0.1\n0 -1 0 0.1\n' > config.txt

# Perform the field estimation
$TOPUP_CMD --imain=pair.nii --datain=config.txt --out=field --config=$TOPUP_CONFIG_PATH

# Convert the image series into something that FSL can recognise
mrconvert ../$3 series_before.nii -stride +1,+2,+3,+4 -quiet

# Apply the warp field to the image series
$APPLYTOPUP_CMD --imain=series_before.nii --datain=config.txt --inindex=1 --topup=field --out=series_after.$FSLSUFFIX --method=jac

# Get the original strides from the volume series using mrinfo, so that the output image can have the same strides
STRIDES=`mrinfo ../$3 | grep "Data strides: "`
STRIDES=${STRIDES##*[ }
STRIDES=${STRIDES%% ]*}
STRIDES=${STRIDES// /,}

# Get the diffusion gradient encoding from the input image (if not present, mrinfo throws an error and grad.b will be empty)
set +e
mrinfo ../$3 -gradient grad.b > /dev/null 2>&1
set -e

# Convert the resulting volume to the output image, and re-insert the diffusion encoding if present
if [[ $(stat -c%s "grad.b") -ne "0" ]]; then
  mrconvert series_after.$FSLSUFFIX ../$4 -stride $STRIDES -grad grad.b -quiet
else
  mrconvert series_after.$FSLSUFFIX ../$4 -stride $STRIDES -quiet
fi

# Delete all working files
rm -f *.*
cd ../
rmdir $TEMP_DIR

set +e

