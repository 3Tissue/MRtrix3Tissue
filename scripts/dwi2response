#!/usr/bin/env python

# Script for estimating response functions for spherical deconvolution
# A number of different approaches are available within this script for performing response function estimation.


import math, os, shutil, sys
import lib.app

from lib.errorMessage  import errorMessage
from lib.getHeaderInfo import getHeaderInfo
from lib.getImageStat  import getImageStat
from lib.printMessage  import printMessage
from lib.runCommand    import runCommand
from lib.warnMessage   import warnMessage


lib.app.initCitations([ 'Tax2014', 'Tournier2013' ])
lib.app.initParser('Estimate response function(s) for spherical deconvolution')


# Groups for individual algorithms
subparsers = lib.app.parser.add_subparsers(title='algorithm choices', description='Select the algorithm to be used to derive the response function', help='Additional help available for individual algorithms: Use e.g. ' + sys.argv[0] + ' fa -help')

parser_fa = subparsers.add_parser('fa', parents=[lib.app.parser], help='Use the old FA-threshold heuristic')
parser_fa_options = parser_fa.add_argument_group('Options specific to the \'fa\' algorithm')
parser_fa_options.add_argument('-erode', type=int, default=3, help='Number of brain mask erosion steps to apply prior to threshold (not used if mask is provided manually)')
parser_fa_options.add_argument('-threshold', type=float, default=0.7, help='Threshold to apply to the FA image')
parser_fa.set_defaults(algorithm='fa')

parser_tax = subparsers.add_parser('tax', parents=[lib.app.parser], help='Use the Tax et al. (2014) recursive calibration algorithm')
parser_tax_options = parser_tax.add_argument_group('Options specific to the \'tax\' algorithm')
parser_tax_options.add_argument('-peak_ratio', type=float, default=0.1, help='Second-to-first-peak amplitude ratio threshold')
parser_tax_options.add_argument('-max_iters', type=int, default=20, help='Maximum number of iterations')
parser_tax_options.add_argument('-convergence', type=float, default=0.5, help='Percentile change in any RF coefficient required to continue iterating')
parser_tax.set_defaults(algorithm='tax')

parser_tournier = subparsers.add_parser('tournier', parents=[lib.app.parser], help='Use the Tournier et al. (2013) iterative RF selection algorithm')
parser_tournier_options = parser_tournier.add_argument_group('Options specific to the \'tournier\' algorithm')
parser_tournier_options.add_argument('-init_voxels', type=int, default=3000, help='Number of single-fibre voxels to select in first iteration')
parser_tournier_options.add_argument('-final_voxels', type=int, default=300, help='Number of single-fibre voxels to select in all subsequent iterations')
parser_tournier_options.add_argument('-max_iters', type=int, default=10, help='Maximum number of iterations')
parser_tournier.set_defaults(algorithm='tournier')

parser_msmt_5tt = subparsers.add_parser('msmt_5tt', parents=[lib.app.parser], help='Derive MSMT CSD responses based on a co-registered 5TT image')
parser_msmt_5tt_options = parser_msmt_5tt.add_argument_group('Arguments & options specific to the \'msmt_5tt\' algorithm')
parser_msmt_5tt_options.add_argument('in_5tt', help='Input co-registered 5TT image')
parser_msmt_5tt.set_defaults(algorithm='msmt_5tt')


# Standard input/output arguments
lib.app.parser.add_argument('input',  help='The input DWI')
lib.app.parser.add_argument('output', help='The output response function file / prefix (for multi-tissue variants)')


# General options
lib.app.parser.add_argument('-shell', help='The b-value shell(s) to use in response function estimation (single value for single-shell response, comma-separated list for multi-shell)')
lib.app.parser.add_argument('-lmax', type=int, default=8, help='The maximum harmonic degree of response function estimation')
lib.app.parser.add_argument('-mask', help='Provide an initial mask for single-fibre voxel selection')
lib.app.parser.add_argument('-sf', help='Output an image showing the final single-voxel selection')
grad_import_group = lib.app.parser.add_mutually_exclusive_group()
grad_import_group.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
grad_import_group.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')


lib.app.initialise()


lib.app.checkOutputFile(lib.app.args.output)
lib.app.checkOutputFile(lib.app.args.sf)
lib.app.checkOutputFile(lib.app.args.grad)
if lib.app.args.fslgrad:
  lib.app.checkOutputFile(lib.app.args.fslgrad[0])
  lib.app.checkOutputFile(lib.app.args.fslgrad[1])


lmax_option = ' -lmax ' + str(lib.app.args.lmax)
shell_option = ''
if lib.app.args.shell:
  shell_option = ' -shell ' + lib.app.args.shell

grad_import_option = ''
if lib.app.args.grad:
  grad_import_option = ' -grad ' + lib.app.args.grad
elif lib.app.args.fslgrad:
  grad_import_option = ' -fslgrad ' + lib.app.args.fslgrad[0] + ' ' + lib.app.args.fslgrad[1]
runCommand('mrconvert ' + lib.app.args.input + ' - -stride 0,0,0,1' + grad_import_option + ' | dwiextract - ' + os.path.join(lib.app.tempDir, 'dwi.mif') + shell_option)
if lib.app.args.mask:
  runCommand('mrconvert ' + lib.app.args.mask + ' ' + os.path.join(lib.app.tempDir, 'mask.mif') + ' -datatype bit')

if lib.app.args.algorithm == 'msmt_5tt':
  runCommand('mrconvert ' + lib.app.args.in_5tt + ' ' + os.path.join(lib.app.tempDir, '5tt.mif'))

lib.app.gotoTempDir()

# Make sure it's actually a DWI that's been passed
size = getHeaderInfo('dwi.mif', 'size').split()
if len(size) != 4:
  errorMessage('Input image must be a 4D image')
DW_scheme = getHeaderInfo('dwi.mif', 'dwgrad').split('\n')
if len(DW_scheme) != int(size[3]):
  errorMessage('Input image does not contain valid DW gradient scheme')
  
# TODO Make sure we have enough for lmax 4?
# Not explicitly required for FA-based algorithm...
# Also may not be required for future algorithms that avoid the amp2sh transform

# Generate a brain mask (if necessary)
# Otherwise, check that the mask provided is appropriate
if lib.app.args.mask:
  dwi_size = getHeaderInfo('dwi.mif', 'size')
  mask_size = getHeaderInfo('mask.mif', 'size')
  if not mask_size == dwi_size[:3]:
    errorMessage('Dimensions of provided mask image do not match DWI')
else:
  runCommand('dwi2mask dwi.mif mask.mif')

# TODO Check validity of lmax
runCommand('amp2sh dwi.mif dwiSH.mif' + shell_option + lmax_option)


# From here, the script splits depending on what estimation algorithm is being used
if lib.app.args.algorithm == 'fa':

  # Old approach: FA threshold, tensor-based directions
  if not lib.app.args.mask:
    runCommand('maskfilter mask.mif erode mask_eroded.mif -npass ' + str(lib.app.args.erode))
    mask_path = 'mask_eroded.mif'
  else:
    mask_path = 'mask.mif'
  runCommand('dwi2tensor dwi.mif -mask ' + mask_path + ' tensor.mif')
  runCommand('tensor2metric tensor.mif -fa fa.mif -vector vector.mif -mask ' + mask_path)
  runCommand('mrthreshold fa.mif SF.mif -abs ' + str(lib.app.args.threshold))
  runCommand('sh2response dwiSH.mif SF.mif vector.mif response.txt' + lmax_option)


elif lib.app.args.algorithm == 'tax':

  # Tax: Iterative calibration using CSD itself, start with full brain mask, only remove voxels at each iteration
  convergence_change = 0.01 * lib.app.args.convergence

  for iteration in range(0, lib.app.args.max_iters):
    prefix = 'iter' + str(iteration) + '_'

    # How to initialise response function?
    # old dwi2response command used mean & standard deviation of DWI data; however
    #   this may force the output FODs to lmax=2 at the first iteration
    # Chantal used a tensor with low FA, but it'd be preferable to get the scaling right
    # Other option is to do as before, but get the ratio between l=0 and l=2, and
    #   generate l=4,6,... using that amplitude ratio
    if iteration == 0:
      RF_in_path = 'init_RF.txt'
      mask_in_path = 'mask.mif'
      runCommand('dwiextract dwi.mif shell.mif')
      # TODO Implement mrstats operating across volumes
      volume_means = [float(x) for x in getImageStat('shell.mif', 'mean', 'mask.mif').split()]
      mean = sum(volume_means) / float(len(volume_means))
      volume_stds = [float(x) for x in getImageStat('shell.mif', 'std', 'mask.mif').split()]
      std = sum(volume_stds) / float(len(volume_stds))
      # Scale these to reflect the fact that we're moving to the SH basis
      mean *= math.sqrt(4.0 * math.pi)
      std  *= math.sqrt(4.0 * math.pi)
      # Now produce the initial response function
      # Let's only do it to lmax 4
      init_RF = [ str(mean), str(-0.5*std), str(0.25*std*std/mean) ]
      with open('init_RF.txt', 'w') as f:
        f.write(' '.join(init_RF))
    else:
      RF_in_path = 'iter' + str(iteration-1) + '_RF.txt'
      mask_in_path = 'iter' + str(iteration-1) + '_SF.mif'
  
    # Run CSD
    runCommand('dwi2fod dwi.mif ' + RF_in_path + ' ' + prefix + 'FOD.mif -mask ' + mask_in_path)
    # Get amplitudes of two largest peaks, and directions of largest
    runCommand('fod2fixel ' + prefix + 'FOD.mif -peak ' + prefix + 'peaks.msf -mask ' + mask_in_path + ' -fmls_no_thresholds')
    runCommand('fixel2voxel ' + prefix + 'peaks.msf split_value ' + prefix + 'amps.mif')
    runCommand('mrconvert ' + prefix + 'amps.mif ' + prefix + 'first_peaks.mif -coord 3 0 -axes 0,1,2')
    runCommand('mrconvert ' + prefix + 'amps.mif ' + prefix + 'second_peaks.mif -coord 3 1 -axes 0,1,2')
    runCommand('fixel2voxel ' + prefix + 'peaks.msf split_dir ' + prefix + 'all_dirs.mif')
    runCommand('mrconvert ' + prefix + 'all_dirs.mif ' + prefix + 'first_dir.mif -coord 3 0:2')
    # Revise single-fibre voxel selection based on ratio of tallest to second-tallest peak
    runCommand('mrcalc ' + prefix + 'second_peaks.mif ' + prefix + 'first_peaks.mif -div ' + prefix + 'peak_ratio.mif')
    runCommand('mrcalc ' + prefix + 'peak_ratio.mif ' + str(lib.app.args.peak_ratio) + ' -lt ' + mask_in_path + ' -mult ' + prefix + 'SF.mif')
    # Make sure image isn't empty
    SF_voxel_count = int(getImageStat(prefix + 'SF.mif', 'count', prefix + 'SF.mif'))
    if not SF_voxel_count:
      errorMessage('Aborting: All voxels have been excluded from single-fibre selection')
    # Generate a new response function
    runCommand('sh2response dwiSH.mif ' + prefix + 'SF.mif ' + prefix + 'first_dir.mif ' + prefix + 'RF.txt' + lmax_option)
    # Detect convergence
    # Look for a change > some percentage - don't bother looking at the masks
    if iteration > 0:
      old_RF_file = open(RF_in_path, 'r')
      old_RF = [ float(x) for x in old_RF_file.read().split() ]
      new_RF_file = open(prefix + 'RF.txt', 'r')
      new_RF = [ float(x) for x in new_RF_file.read().split() ]
      reiterate = False
      for index in range(0, len(old_RF)):
        mean = 0.5 * (old_RF[index] + new_RF[index])
        diff = math.fabs(0.5 * (old_RF[index] - new_RF[index]))
        ratio = diff / mean
        if ratio > convergence_change:
          reiterate = True
      if not reiterate:
        printMessage('Exiting at iteration ' + str(iteration) + ' with ' + str(SF_voxel_count) + ' SF voxels due to unchanged response function coefficients')
        shutil.copyfile(prefix + 'RF.txt', 'response.txt')
        shutil.copyfile(prefix + 'SF.mif', 'SF.mif')
        break
  # Go to the next iteration

  # If we've terminated due to hitting the iteration limiter, we still need to copy the output file(s) to the correct location
  if not os.path.exists('response.txt'):
    printMessage('Exiting after maximum ' + str(iteration) + ' iterations with ' + str(SF_voxel_count) + ' SF voxels')
    os.copy('iter' + str(lib.app.args.max_iters-1) + '_RF.txt', 'response.txt')
    os.copy('iter' + str(lib.app.args.max_iters-1) + '_SF.mif', 'SF.mif')

    
elif lib.app.args.algorithm == 'tournier':

# Tournier: Use [1 -1 1] as initial response, run CSD, select top 3000? voxels, new RF, dilate mask by 1 voxel, run CSD, select top 300? voxels
  if lib.app.args.max_iters < 2:
    errorMessage('Number of iterations must be at least 2')

  for iteration in range(0, lib.app.args.max_iters):
    prefix = 'iter' + str(iteration) + '_'
  
    if iteration == 0:
      RF_in_path = 'init_RF.txt'
      mask_in_path = 'mask.mif'
      init_RF = '1 -1 1'
      with open('init_RF.txt', 'w') as f:
        f.write(init_RF);
      lmax_option = ' -lmax 4'
      num_SF_voxels = lib.app.args.init_voxels
    else:
      RF_in_path = 'iter' + str(iteration-1) + '_RF.txt'
      mask_in_path = 'iter' + str(iteration-1) + '_SF_dilated.mif'
      lmax_option = ''
      num_SF_voxels = lib.app.args.final_voxels

    # Run CSD
    runCommand('dwi2fod dwi.mif ' + RF_in_path + ' ' + prefix + 'FOD.mif -mask ' + mask_in_path + lmax_option)
    # Get amplitudes of two largest peaks, and direction of largest
    # TODO Speed-test fod2fixel against sh2peaks
    # TODO Add maximum number of fixels per voxel option to fod2fixel?
    runCommand('fod2fixel ' + prefix + 'FOD.mif -peak ' + prefix + 'peaks.msf -mask ' + mask_in_path + ' -fmls_no_thresholds')
    runCommand('fixel2voxel ' + prefix + 'peaks.msf split_value ' + prefix + 'amps.mif')
    runCommand('mrconvert ' + prefix + 'amps.mif ' + prefix + 'first_peaks.mif -coord 3 0 -axes 0,1,2')
    runCommand('mrconvert ' + prefix + 'amps.mif ' + prefix + 'second_peaks.mif -coord 3 1 -axes 0,1,2')
    runCommand('fixel2voxel ' + prefix + 'peaks.msf split_dir ' + prefix + 'all_dirs.mif')
    runCommand('mrconvert ' + prefix + 'all_dirs.mif ' + prefix + 'first_dir.mif -coord 3 0:2')
    # Calculate the 'cost function' Donald derived for selecting single-fibre voxels
    # https://github.com/MRtrix3/mrtrix3/pull/426
    #  sqrt(|peak1|) * (1 - |peak2| / |peak1|)^2
    runCommand('mrcalc ' + prefix + 'first_peaks.mif -sqrt 1 ' + prefix + 'second_peaks.mif ' + prefix + 'first_peaks.mif -div -sub 1 ' + prefix + 'second_peaks.mif ' + prefix + 'first_peaks.mif -div -sub -mult -mult ' + prefix + 'CF.mif')
    # Select the top-ranked voxels
    runCommand('mrthreshold ' + prefix + 'CF.mif -top ' + str(num_SF_voxels) + ' ' + prefix + 'SF.mif')
    # Generate a new response function based on this selection
    runCommand('sh2response dwiSH.mif ' + prefix + 'SF.mif ' + prefix + 'first_dir.mif ' + prefix + 'RF.txt' + lmax_option)
    # Should we terminate?
    if iteration > 0:
      runCommand('mrcalc ' + prefix + 'SF.mif iter' + str(iteration-1) + '_SF.mif -sub ' + prefix + 'SF_diff.mif')
      max = getImageStat(prefix + 'SF_diff.mif', 'max')
      if int(max) == 0:
        printMessage('Convergence of SF voxel selection detected at iteration ' + str(iteration))
        shutil.copyfile(prefix + 'RF.txt', 'response.txt')
        shutil.copyfile(prefix + 'SF.mif', 'SF.mif')
        break
    
    # Dilate the initial single-voxel mask; these are the voxels that will be re-tested in the next iteration
    runCommand('maskfilter ' + prefix + 'SF.mif dilate ' + prefix + 'SF_dilated.mif')

  # Commence the next iteration


elif lib.app.args.algorithm == 'msmt_5tt':


# Multi-shell (5TT-based): Provide 5TT image, do re-gridding to DWI space, select pure voxels, generate RF, recursively call self to get WM responses?
# Will have multiple RF file outputs; output path becomes a prefix

# Ideally want to use the oversampling-based regridding of the 5TT image from the SIFT model, not mrtransform
# May need to commit 5ttregrid...

  errorMessage('msmt_5tt response function estimation algorithm not yet implemented')










# Multi-shell, multi-tissue; but based on a strict input voxel mask, e.g. Ben's current msdwi2response script












shutil.copyfile('response.txt', os.path.join(lib.app.workingDir, lib.app.args.output))
if lib.app.args.sf:
  runCommand('mrconvert SF.mif ' + os.path.join(lib.app.workingDir, lib.app.args.sf) + lib.app.mrtrixForce)
lib.app.complete()

