#!/usr/bin/env python

# Script for estimating response functions for spherical deconvolution
# A number of different approaches are available within this script for performing response function estimation.


import argparse, math, os, shutil, sys
import lib.algorithm
import lib.app
import lib.cmdlineParser
import lib.image
import lib.message
import lib.path

from lib.runCommand import runCommand


lib.app.author = 'Robert E. Smith (robert.smith@florey.edu.au) and Thijs Dhollander (thijs.dhollander@gmail.com)'
lib.cmdlineParser.initialise('Estimate response function(s) for spherical deconvolution')

# General options
base_parser = lib.cmdlineParser.Parser(description='Base parser for dwi2response script', parents=[lib.app.parser], add_help=False)
common_options = base_parser.add_argument_group('Options common to all dwi2response algorithms')
common_options.add_argument('-shell', help='The b-value shell(s) to use in response function estimation (single value for single-shell response, comma-separated list for multi-shell response)')
common_options.add_argument('-lmax', help='The maximum harmonic degree(s) of response function estimation (single value for single-shell response, comma-separated list for multi-shell response)')
common_options.add_argument('-mask', help='Provide an initial mask for response voxel selection')
common_options.add_argument('-voxels', help='Output an image showing the final voxel selection(s)')
common_options.add_argument('-grad', help='Pass the diffusion gradient table in MRtrix format')
common_options.add_argument('-fslgrad', nargs=2, metavar=('bvecs', 'bvals'), help='Pass the diffusion gradient table in FSL bvecs/bvals format')
lib.cmdlineParser.flagMutuallyExclusiveOptions( [ 'grad', 'fslgrad' ] )
base_parser.set_defaults(single_shell=False)
base_parser.set_defaults(needs_bzero=False)

# Subparsers for individual algorithms
subparsers = lib.app.parser.add_subparsers(title='Algorithm choices', help='Select the algorithm to be used to derive the response function; additional details and options become available once an algorithm is nominated. Options are: ' + ', '.join(lib.algorithm.getList()), dest='algorithm')

# Import the command-line settings for all algorithms found in the relevant directory
lib.algorithm.initialise(base_parser, subparsers)


lib.app.initialise()


# Find out which algorithm the user has requested
algorithm = lib.algorithm.getModule(lib.app.args.algorithm)


# Check for prior existence of output files, and grab any input files, used by the particular algorithm
lib.app.checkOutputFile(lib.app.args.voxels)
algorithm.checkOutputFiles()


# Sanitise some inputs, and get ready for data import
if lib.app.args.lmax:
  try:
    lmax = [ int(x) for x in lib.app.args.lmax.split(',') ]
    if any([lmax_value%2 for lmax_value in lmax]):
      lib.message.error('Value of lmax must be even')
  except:
    lib.message.error('Parameter lmax must be a number')
  if lib.app.args.single_shell and not len(lmax) == 1:
    lib.message.error('Can only specify a single lmax value for single-shell algorithms')
shell_option = ''
if lib.app.args.shell:
  try:
    shell_values = [ int(x) for x in lib.app.args.shell.split(',') ]
  except:
    lib.message.error('-shell option should provide a comma-separated list of b-values')
  if lib.app.args.single_shell and not len(shell_values) == 1:
    lib.message.error('Can only specify a single b-value shell for single-shell algorithms')
  shell_option = ' -shell ' + lib.app.args.shell
singleshell_option = ''
if lib.app.args.single_shell:
  singleshell_option = ' -singleshell -no-bzero'

grad_import_option = ''
if lib.app.args.grad:
  grad_import_option = ' -grad ' + lib.path.fromUser(lib.app.args.grad, True)
elif lib.app.args.fslgrad:
  grad_import_option = ' -fslgrad ' + lib.path.fromUser(lib.app.args.fslgrad[0], True) + ' ' + lib.path.fromUser(lib.app.args.fslgrad[1], True)
elif not lib.image.headerField(lib.path.fromUser(lib.app.args.input, False), 'dwgrad'):
  lib.message.error('Script requires diffusion gradient table: either in image header, or using -grad / -fslgrad option')

lib.app.makeTempDir()

# Get standard input data into the temporary directory
if lib.app.args.single_shell or shell_option:
  runCommand('mrconvert ' + lib.path.fromUser(lib.app.args.input, True) + ' - -stride 0,0,0,1' + grad_import_option + ' | dwiextract - ' + os.path.join(lib.app.tempDir, 'dwi.mif') + shell_option + singleshell_option)
else: # Don't want to discard b=0 in multi-shell algorithms, which dwiextract will do
  runCommand('mrconvert ' + lib.path.fromUser(lib.app.args.input, True) + ' ' + os.path.join(lib.app.tempDir, 'dwi.mif') + ' -stride 0,0,0,1' + grad_import_option)
if lib.app.args.needs_bzero:
  runCommand('mrconvert ' + lib.path.fromUser(lib.app.args.input, True) + ' - -stride 0,0,0,1' + grad_import_option + ' | dwiextract - ' + os.path.join(lib.app.tempDir, 'bzero.mif') + " -bzero")
if lib.app.args.mask:
  runCommand('mrconvert ' + lib.path.fromUser(lib.app.args.mask, True) + ' ' + os.path.join(lib.app.tempDir, 'mask.mif') + ' -datatype bit')

algorithm.getInputFiles()

lib.app.gotoTempDir()
  

# Generate a brain mask (if necessary)
# Otherwise, check that the mask provided is appropriate
if os.path.exists('mask.mif'):
  dwi_size = [ int(x) for x in lib.image.headerField('dwi.mif', 'size').split() ]
  mask_size = [ int(x) for x in lib.image.headerField('mask.mif', 'size').split() ]
  if not mask_size[:3] == dwi_size[:3]:
    lib.message.error('Dimensions of provided mask image do not match DWI')
  if int(lib.image.statistic('mask.mif', 'count', 'mask.mif')) == 0:
    lib.message.error('Input mask does not contain any voxels')
else:
  runCommand('dwi2mask dwi.mif mask.mif')


# From here, the script splits depending on what estimation algorithm is being used
algorithm.execute()


# Finalize for all algorithms
if lib.app.args.voxels:
  runCommand('mrconvert voxels.mif ' + lib.path.fromUser(lib.app.args.voxels, True) + lib.app.mrtrixForce)
lib.app.complete()

