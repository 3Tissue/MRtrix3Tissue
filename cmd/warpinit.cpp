/*
    Copyright 2008 Brain Research Institute, Melbourne, Australia

    Written by J-Donald Tournier, 27/06/08.

    This file is part of MRtrix.

    MRtrix is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    MRtrix is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with MRtrix.  If not, see <http://www.gnu.org/licenses/>.

*/

#include "command.h"
#include "image.h"
#include "stride.h"
#include "transform.h"
#include "algo/threaded_loop.h"


using namespace MR;
using namespace App;

void usage ()
{
  DESCRIPTION
  + "create an initial warp image, representing an identity transformation. "
    "This is useful to obtain the warp fields from other normalisation "
    "applications, by applying the transformation of interest to the "
    "warp field generated by this program." 

  + "The image generated is a 4D image with the same spatial characteristics as "
    "the input template image. It contains 3 volumes, with each voxel containing "
    "its own x,y,z coordinates."
    
    + "Note that this command can be used to create 3 separate X,Y,Z images "
    "directly (which may be useful to create images suitable for use in the "
    "registration program) using the following syntax:"

    + "  $ warpinit template.mif warp-[].nii";

  ARGUMENTS
  + Argument ("template", "the input template image.").type_image_in ()
  + Argument ("warp", "the output warp image.").type_image_out ();
}


class write_coordinates {
  public:
    template <class HeaderType>
      write_coordinates (const HeaderType& in) :
        transform (in) { }

    template <class ImageType>
      void operator() (ImageType& image) const {
        Eigen::Vector3 voxel_pos ((default_type)image.index(0), (default_type)image.index(1), (default_type)image.index(2));
        image.row(3) = (transform.voxel2scanner * voxel_pos).cast<typename ImageType::value_type>();
      }

  private:
    const Transform transform;
};


void run ()
{
  auto header = Header::open (argument[0]);

  header.datatype() = DataType::Float32;
  header.set_ndim (4);
  header.size(3) = 3;
  Stride::set (header, Stride::contiguous_along_axis (3));

  auto warp = Image<float>::create(argument[1], header);

  ThreadedLoop ("generating identity warp...", warp, 0, 3)
    .run (write_coordinates (warp), warp);
}
