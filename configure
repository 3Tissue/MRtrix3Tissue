#!/usr/bin/python

import subprocess, sys, tempfile, os, platform, tempfile, shutil

debug = False
profile = False
nogui = False
noshared = False
static = False
verbose = False
profile_name = None

for arg in sys.argv[1:]:
  if '-debug'.startswith (arg): debug = True
  elif '-profile'.startswith (arg): profile = True
  elif '-nogui'.startswith (arg): nogui = True
  elif '-noshared'.startswith (arg): noshared = True
  elif '-static'.startswith (arg): 
    static = True
    noshared = True
  elif '-verbose'.startswith (arg): verbose = True
  elif arg[0] != '-':
    if profile_name != None: 
      print 'configure: too many names supplied'
      sys.exit (1)
    profile_name = arg
  else: 
    print """\
usage: [ENV] ./configure [name] [-debug] [-profile] [-nogui] [-noshared]'

In most cases, a simple invocation should work:

   $ ./configure

If a name is provided, the configuration will be written to a different file, 
which can then be used by the build script. For example:

   $ ./configure testing -debug

will generate the file 'config.testing', which can be used with the build
script as follows:

   $ ./build testing

Note that all intermediate files will be named according to the name of the
configuration to avoid conflict with any other configuration.


OPTIONS:

    -debug       enable debugging symbols.

    -profile     enable profiling.

    -nogui       disable GUI components.

    -noshared    disable shared library generation.

    -static      produce statically-linked executables.

    -verbose     enable more informative output.


ENVIRONMENT VARIABLES:

For non-standard setups, you may need to supply additional
information using environment variables. For example, to set
the compiler, use:
   $ CXX=/usr/local/bin/g++-4.1 ./configure

The following environment variables can be set:

CXX             The compiler command-line to use. The default is:
                "g++ -c CFLAGS SRC -o OBJECT"

LD              The linker command-line to use. The default is:
                "g++ LDFLAGS OBJECTS -o EXECUTABLE"

LDLIB           The linker command-line to use for generating a shared library.
                The default is:
                "g++ -shared LDLIB_FLAGS OBJECTS -o LIB"

ARCH            the specific CPU architecture to compile for. This variable 
                will be passed to the compiler using -march=$ARCH.
                The default is 'native'.

CFLAGS          Any additional flags to the compiler.

LDFLAGS         Any additional flags to the linker.

LDLIB_FLAGS     Any additional flags to the linker to generate a shared library.

PTHREAD_CFLAGS  Any flags required to compile with POSIX threads.

PTHREAD_LDFLAGS Any flags required to link with POSIX threads.

GSL_CFLAGS      Any flags required to compile with the GSL.
                This may include in particular the path to the
                include files, if not in a standard location
                For example:
                $ GSL_CFLAGS="-I/usr/local/include" ./configure

GSL_LDFLAGS     Any flags required to link with the GSL.
                This may include in particular the path to the
                libraries, if not in a standard location
                For example:
                $ GSL_LDFLAGS="-L/usr/local/lib -lgsl -lgslcblas" ./configure

ZLIB_CFLAGS     Any flags required to compile with the zlib compression library.

ZLIB_LDFLAGS    Any flags required to link with the zlib compression library.

CBLAS_LDFLAGS   Any flags required to link with an alternate cblas library.

QMAKE           The command to run to invoke qmake. 

MOC             The command to invoke Qt4's meta-object compile (default: moc-qt4)

PATH            Set the path to use during the configure process.
                This may be useful to set the path to Qt4's qmake.
                For example:
                $ PATH=/usr/local/bin:$PATH ./configure

                Note that this path will NOT be used during the build
                process itself.
"""
    sys.exit (0)
  

if not profile_name:
  profile_name = 'default'


global logfile, config_report
logfile = open (os.path.join (os.path.dirname(sys.argv[0]), 'configure.log'), 'w')
config_report = ''


def log (message):
  global logfile
  logfile.write (message)
  if (verbose): 
    sys.stdout.write (message)
    sys.stdout.flush()

def report (message):
  global config_report, logfile
  config_report += message
  sys.stdout.write (message)
  sys.stdout.flush()
  logfile.write ('\nREPORT: ' + message.rstrip() + '\n')

def error (message):
  global logfile
  logfile.write ('\nERROR: ' + message.rstrip() + '\n\n')
  sys.stderr.write ('\nERROR: ' + message.rstrip() + '\n\n')
  sys.exit (1)


report ("""
MRtrix build type requested: """)
if profile: report ('profiling')
elif debug: report ('debug')
else: report ('release')
if nogui: report (' [command-line only]')
report ('\n\n')




global cpp, cpp_cmd, ld, ld_cmd

cpp = 'g++ -c CFLAGS SRC -o OBJECT'.split()
cpp_flags = [ '-fPIC', '-Wno-unused-parameter' ]

ld = 'g++ OBJECTS LDFLAGS -o EXECUTABLE'.split()
ld_flags = []

ld_lib = 'g++ -shared LDLIB_FLAGS OBJECTS -o LIB'.split()
ld_lib_flags = []

thread_cflags = []
thread_ldflags = [ '-lpthread' ]

zlib_cflags = []
zlib_ldflags = [ '-lz' ]

gsl_cflags = []
gsl_ldflags = [ '-lgsl', '-lgslcblas' ]


class TempFile:
  def __init__ (self, suffix):
    self.fid = None
    self.name = None
    [ fid, self.name ] = tempfile.mkstemp (suffix)
    self.fid = os.fdopen (fid, 'w')

  def __del__ (self):
    try:
      os.unlink (self.name)
    except OSError:
      log ('error deleting temporary file "' + self.name + '"')


class DeleteAfter:
  def __init__ (self, name):
    self.name = name

  def __del__ (self):
    try:
      os.unlink (self.name)
    except OSError:
      log ('error deleting temporary file "' + self.name + '"')
    
    
class TempDir:
  def __init__ (self):
    self.name = tempfile.mkdtemp ();

  def __del__ (self):
    try:
      for entry in os.listdir (self.name):
        os.remove (os.path.join (self.name, entry))
      os.rmdir (self.name)
    except OSError:
      log ('error deleting temporary folder "' + self.name + '"')



class QMakeError: pass
class QMOCError: pass
class CompileError: pass
class LinkError: pass
class RuntimeError: pass

def commit (name, variable):
  cache.write (name + ' = ')
  if type (variable) == type([]): 
    cache.write ('[')
    if len(variable): cache.write(' \'' + '\', \''.join (variable) + '\' ')
    cache.write (']\n')
  else: cache.write ('\'' + variable + '\'\n')



def fillin (template, keyvalue):
  cmd = []
  for item in template:
    if item in keyvalue: 
      if type(keyvalue[item]) == type ([]): cmd += keyvalue[item]
      else: cmd += [ keyvalue[item] ]
    else: cmd += [ item ]
  return cmd



def execute (cmd, exception, raise_on_non_zero_exit_code = True, cwd = None):
  log ('EXEC <<\nCMD: ' + ' '.join(cmd) + '\n')
  try: 
    process = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=cwd)
    ( stdout, stderr ) = process.communicate()
  except OSError as error: 
    log ('error invoking command "' + cmd[0] + '": ' + os.strerror (error.errno) + '\n>>\n\n')
    raise exception
  log ('EXIT: ' + str(process.returncode) + '\n')
  stdout = stdout.rstrip()
  if len (stdout): log ('STDOUT:\n' + stdout + '\n')
  stderr = stderr.rstrip()
  if len (stderr): log ('STDERR:\n' + stderr + '\n')
  log ('>>\n\n')
  if raise_on_non_zero_exit_code and process.returncode != 0: raise exception
  return (process.returncode, stdout, stderr)

  

def compile (source, compiler_flags = [], linker_flags = []):
  global cpp, ld
  F = TempFile ('.cpp')
  log ('\nCOMPILE ' + F.name + ':\n---\n' + source + '\n---\n')
  F.fid.write (source)
  F.fid.flush()
  obj = DeleteAfter (F.name[:-4] + '.o')
  cmd = fillin (cpp, {
    'CFLAGS': compiler_flags,
    'SRC': F.name,
    'OBJECT': obj.name })
  execute (cmd, CompileError)

  out = DeleteAfter ('./a.out')
  cmd = fillin (ld, {
    'LDFLAGS': linker_flags,
    'OBJECTS': obj.name,
    'EXECUTABLE': out.name })
  execute (cmd, LinkError)

  ret = execute ([ out.name ], RuntimeError)

  return ret[1]









# set CPP compiler:

if 'CXX' in os.environ.keys(): cpp = os.environ['CXX'].split()
if 'LD' in os.environ.keys(): ld = os.environ['LD'].split()
if 'LDLIB' in os.environ.keys(): ld_lib = os.environ['LDLIB'].split()

report ('Checking C++ compiler [' + cpp[0] + ']: ')
try: 
  compiler_version = execute ([ cpp[0], '-dumpversion' ], CompileError)[1]
  if len(compiler_version) == 0: report ('(no version information)')
  else: report (compiler_version)
except:
  error ('''compiler not found!

Use CXX environment variable to set path to compiler, as follows:
     CXX=/usr/bin/g++-4.2 ./configure.py''')

try:
  compile ('int main() { return (0); }', cpp_flags, ld_flags)
  report (' - tested ok\n')
except CompileError:
  error ('''compiler error!

Use CXX environment variable to set path to compiler, as follows:
     CXX=/usr/bin/g++-4.2 ./configure.py''')
except (LinkError, RuntimeError):
  error ('''linking error!

Use LD environment variable to set path to compiler, as follows:
     LD=/usr/bin/g++-4.2 ./configure.py''')




# CPP flags:

if 'CFLAGS' in os.environ.keys(): cpp_flags = os.environ['CFLAGS'].split()
if 'LDFLAGS' in os.environ.keys(): ld_flags = os.environ['LDFLAGS'].split()
if 'LDLIB_FLAGS' in os.environ.keys(): ld_lib_flags = os.environ['LDLIB_FLAGS'].split()


# OS-dependent variables:

obj_suffix = '.o'
exe_suffix = ''
lib_prefix = 'lib'

system = platform.system().lower()
report ('Detecting OS: ' + system + '\n')
if system == 'linux':
  lib_suffix = '.so'
elif system == 'windows':
  cpp_flags += [ '-DWINDOWS', '-mno-cygwin', '-mms-bitfields' ]
  exe_suffix = '.exe'
  lib_prefix = ''
  lib_suffix = '.dll'
elif system == 'darwin':
  cpp_flags += [ '-DMACOSX', '-fPIC' ]
  ld_flags += [ '-dynamiclib' ]
  lib_suffix = '.dylib'




if 'ARCH' in os.environ.keys(): 
  march = os.environ['ARCH']
  report ('Machine architecture set by ARCH environment variable to: ' + march + '\n')
  cpp_flags += [ '-march='+march ]





report ('Detecting pointer size: ')
try:
  pointer_size = int (compile ('''
#include <iostream>
int main() { 
  std::cout << sizeof(void*); 
  return (0);
}
''', cpp_flags, ld_flags))
  report (str(8*pointer_size) + ' bit\n')
  if pointer_size == 8: cpp_flags += [ '-DWORD64' ]
  elif pointer_size != 4: 
    error ('unexpected pointer size!')
except:
  error ('unable to determine pointer size!')




report ('Detecting byte order: ')
if sys.byteorder == 'big':
  report ('big-endian\n')
  cpp_flags += [ '-DBYTE_ORDER_IS_BIG_ENDIAN' ]
else:
  report ('little-endian\n')



report ('Checking for C++ TR1 implementation: ')
try:
  compile ('''
#include <tr1/unordered_map>

int main() { 
  std::tr1::unordered_map<int,int> map; 
  return (map.size());
}
''', cpp_flags, ld_flags)
  report ('present\n')
  cpp_flags += [ '-DUSE_TR1' ]
except:
  report ('not present - using SGI hash_map instead\n')




report ('Checking for 64-bit integer type: ')
try:
  compile ('''
#include <stdint.h>

int main() { 
  int64_t t = 0; 
  return (t); 
}
''', cpp_flags, ld_flags)
  report ('yes\n')
except:
  report ('no\n')
  error ('<stdint.h> is not C99 compliant - it does not define a int64_t type.')




# zlib:

report ('Checking for zlib compression library: ')

if 'ZLIB_CFLAGS' in os.environ.keys(): zlib_cflags = os.environ['ZLIB_CFLAGS'].split()
if 'ZLIB_LDFLAGS' in os.environ.keys(): zlib_ldflags = os.environ['ZLIB_LDFLAGS'].split()

try:
  zlib_version = compile ('''
#include <iostream>
#include <zlib.h>

int main() { 
  std::cout << zlibVersion(); 
  return (0);
}
''', cpp_flags + zlib_cflags, ld_flags + zlib_ldflags)
  report (zlib_version + '\n')
except CompileError:
  error ('''compiler error!

Use the ZLIB_CFLAGS environment variable to set the path to
the zlib include files and to set any required flags
For example:
     ZLIB_CFLAGS="-I/usr/local/include" ./configure.py''')
except LinkError:
  error ('''linker error!

Use the ZLIB_LDFLAGS environment variable to set the path to
the zlib libraries and to set the library to use
For example:
     ZLIB_LDFLAGS="-L/usr/local/lib -lz" ./configure.py''')
except RuntimeError:
  error ('''runtime error!

There is something wrong with your zlib implementation!''')
except:
  error ('zlib implementation not found!')

cpp_flags += zlib_cflags
ld_flags += zlib_ldflags
ld_lib_flags += zlib_ldflags





# POSIX threads:

report ('Checking for POSIX threads: ')

if 'PTHREAD_CFLAGS' in os.environ.keys(): thread_cflags = os.environ['PTHREAD_CFLAGS'].split()
if 'PTHREAD_LDFLAGS' in os.environ.keys(): thread_ldflags = os.environ['PTHREAD_LDFLAGS'].split()

try:
  compile ('''
#include <pthread.h>

void* func (void*) { return (NULL); } 

int main() { 
  pthread_t t; 
  if (pthread_create(&t, NULL, func, NULL)) return (1);
  pthread_exit (NULL); 
  return (0); 
}
''', cpp_flags + thread_cflags, ld_flags + thread_ldflags)
  report ('yes\n')
except CompileError:
  error ('''compiler error!

Use the PTHREAD_CFLAGS environment variable to set the path to
the pthread include files and to set any required flags
For example:
     PTHREAD_CFLAGS="-I/usr/local/include" ./configure.py''')
except LinkError:
  error ('''linker error!

Use the PTHREAD_LDFLAGS environment variable to set the path to
the pthread libraries and to set the library to use
For example:
     PTHREAD_LDFLAGS="-L/usr/local/lib -lpthread" ./configure.py''')
except RuntimeError:
  error ('''runtime error!

There is something wrong with your POSIX threads implementation!''')
except:
  error (' POSIX threads implementation not found!')




# GSL flags:

report ('Checking for GNU Scientific Library: ')
if 'GSL_CFLAGS' in os.environ.keys(): gsl_cflags = os.environ['GSL_CFLAGS'].split()
if 'GSL_LDFLAGS' in os.environ.keys(): gsl_ldflags = os.environ['GSL_LDFLAGS'].split()

try:
  gsl_version = compile ('''
#include <iostream>
#include <gsl/gsl_version.h>
#include <gsl/gsl_matrix.h>

int main() { 
  std::cout << gsl_version; 
  gsl_matrix* M = gsl_matrix_alloc (3,3); 
  return (M->size1 != 3);
}
''', cpp_flags + gsl_cflags, ld_flags + gsl_ldflags)
  report (gsl_version + '\n')
except CompileError:
  error ('''compiler error!

Use the GSL_CFLAGS environment variable to set the path to the GSL include files'
For example:'
     GSL_CFLAGS=-I/usr/local/include ./configure.py''')
except LinkError:
  error ('''linker error!'

Use the GSL_LDFLAGS environment variable to set the path to the GSL libraries'
and include any required libraries'
For example:'
     GSL_LDFLAGS="-L/usr/local/lib -lgsl -lgslcblas" ./configure.py''')



report ('Checking whether GSL compiles with -DHAVE_INLINE: ')
try:
  gsl_version = compile ('''
#include <gsl/gsl_matrix.h>
int main() { 
  gsl_matrix* M = gsl_matrix_alloc (3,3); 
  gsl_matrix_set(M,0,0,3.14); 
  return (gsl_matrix_get(M,0,0) != 3.14); 
}''', cpp_flags + gsl_cflags + [ '-DHAVE_INLINE' ], ld_flags + gsl_ldflags)
  gsl_cflags += [ '-DHAVE_INLINE' ]
  report ('yes\n')
except:
  report ('no\n')




# check for alternate cblas libraries:

if 'CBLAS_LDFLAGS' in os.environ.keys(): 
  cblas_ldflags = os.environ['CBLAS_LDFLAGS'].split()
  flags = gsl_ldflags[:]
  flags.remove ('-lgslcblas')
  flags += cblas_ldflags;
  report ('Checking whether GSL compiles with alternate C BLAS libraries ("' + ' '.join(cblas_ldflags) + '"): ')
  try:
    compile ('''
#include <iostream>
#include <gsl/gsl_version.h>
#include <gsl/gsl_matrix.h>

int main() { 
  std::cout << gsl_version; 
  gsl_matrix* M = gsl_matrix_alloc (3,3); 
  return (M->size1 != 3);
}
''', cpp_flags + gsl_cflags, ld_flags + flags)
    report ('yes\n')
    gsl_ldflags = flags
  except:
    error ('''Error compiling and/or linking with alternative C BLAS libraries provided!
Check whether the information provided by the CBLAS_LDFLAGS environment
variable is correct.''')







# shared library generation:
if not noshared:
  report ('Checking shared library generation: ')

  F = TempFile ('.cpp')
  F.fid.write ('int bogus() { return (1); }')
  F.fid.flush()
  obj = DeleteAfter (F.name[:-4] + '.o')
  cmd = fillin (cpp, {
    'CFLAGS': cpp_flags,
    'SRC': F.name,
    'OBJECT': obj.name })
  try: execute (cmd, CompileError)
  except CompileError:
    error ('''compiler not found!

  an unexpected error occurred''')
  
  lib = DeleteAfter (lib_prefix + 'test' + lib_suffix)
  cmd = fillin (ld_lib, {
    'LDLIB_FLAGS': ld_lib_flags,
    'OBJECTS': obj.name,
    'LIB': lib.name })
  try: execute (cmd, LinkError)
  except LinkError: 
    error ('''linker not found!

  Use the LDLIB environment variable to set the command-line
  for shared library generation''')

  report ('yes\n')





qmake = [ 'qmake' ]
moc = 'moc-qt4' 
qt_cflags = []
qt_ldflags = []


if not nogui:

  report ('Checking for Qt4: ')

  if 'QMAKE' in os.environ.keys(): qmake = os.environ['QMAKE'].split()
  if 'MOC' in os.environ.keys(): moc = os.environ['MOC']

  try:
    qt_dir = TempDir()
    file = '''#include <QObject>

class Foo: public QObject {
  Q_OBJECT;
  public:
    Foo();
    ~Foo();
  public slots:
    void setValue(int value);
  signals:
    void valueChanged (int newValue);
  private:
    int value_;
};
'''
    log ('\nsource file "qt.h":\n---\n' + file + '---\n')

    f=open (os.path.join (qt_dir.name, 'qt.h'), 'w')
    f.write (file)
    f.close();

    file = '''#include <iostream>
#include "qt.h"

Foo::Foo() : value_ (42) { connect (this, SIGNAL(valueChanged(int)), this, SLOT(setValue(int))); }

Foo::~Foo() { std::cout << qVersion() << "\\n"; }

void Foo::setValue (int value) { value_ = value; }

int main() { Foo f; }
'''

    log ('\nsource file "qt.cpp":\n---\n' + file + '---\n')
    f=open (os.path.join (qt_dir.name, 'qt.cpp'), 'w')
    f.write (file)
    f.close();

    file = 'CONFIG += qt'
    if debug: file += ' debug'
    file += '\nQT += opengl\nHEADERS += qt.h\nSOURCES += qt.cpp\n'

    log ('\nproject file "qt.pro":\n---\n' + file + '---\n')
    f=open (os.path.join (qt_dir.name, 'qt.pro'), 'w')
    f.write (file)
    f.close();

    try: execute (qmake, QMakeError, cwd=qt_dir.name)
    except QMakeError:
      error ('''error issuing qmake command!

  Use the QMAKE environment variable to set the correct qmake command for use with Qt4''')
     

    qt_defines = [] 
    qt_includes = []
    qt_cflags = []
    qt_libs = []
    qt_ldflags = []

    for line in open (os.path.join (qt_dir.name, 'Makefile')):
      line = line.strip()
      if line.startswith ('DEFINES'):
        qt_defines = line[line.find('=')+1:].strip().split()
      elif line.startswith ('CXXFLAGS'):
        qt_cflags = line[line.find('=')+1:].strip().split()
      elif line.startswith ('INCPATH'):
        qt_includes = line[line.find('=')+1:].strip().split()
      elif line.startswith ('LIBS'):
        qt_libs = line[line.find('=')+1:].strip().split()
      elif line.startswith ('LFLAGS'):
        qt_ldflags = line[line.find('=')+1:].strip().split()

    qt = qt_cflags + qt_defines + qt_includes
    qt_cflags = []
    for entry in qt:
      if entry[0] != '$' and not entry == '-I.': qt_cflags += [ entry ]

    qt = qt_ldflags + qt_libs
    qt_ldflags = []
    for entry in qt:
      if entry[0] != '$': qt_ldflags += [ entry ]

    cmd = [ moc, 'qt.h', '-o', 'qt_moc.cpp' ]
    log ('\nexecuting "' + ' ' .join(cmd) + '"...\n')
    try: process = subprocess.Popen (cmd, cwd=qt_dir.name, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise QMOCError
    if process.wait() != 0: raise QMOCError

    cmd = [ 'g++', '-c' ] + cpp_flags + qt_cflags + [ 'qt.cpp', '-o', 'qt.o' ]
    log ('\nexecuting "' + ' ' .join(cmd) + '"...\n')
    try: process = subprocess.Popen (cmd, cwd=qt_dir.name, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise CompileError
    if process.wait() != 0: raise CompileError

    cmd = [ 'g++', '-c' ] + cpp_flags + qt_cflags + [ 'qt_moc.cpp', '-o', 'qt_moc.o' ]
    log ('\nexecuting "' + ' ' .join(cmd) + '"...\n')
    try: process = subprocess.Popen (cmd , cwd=qt_dir.name, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise CompileError
    if process.wait() != 0: raise CompileError

    cmd = [ 'g++' ] + ld_flags + [ 'qt_moc.o', 'qt.o', '-o', 'qt' ] + qt_ldflags
    log ('\nexecuting "' + ' ' .join(cmd) + '"...\n')
    try: process = subprocess.Popen (cmd , cwd=qt_dir.name, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    except OSError: raise LinkError
    if process.wait() != 0: raise LinkError

    cmd = os.path.join(qt_dir.name, 'qt')
    log ('\nexecuting "' + cmd + '"...\n')
    process = subprocess.Popen (cmd, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
    if process.wait() != 0: raise LinkError
    report (process.stdout.read().strip() + '\n')

    
  except QMakeError:
    error ('''error invoking Qt4 qmake!

  Use the QMAKE environment variable to set the correct qmake command for use with Qt4''')
  except QMOCError:
    error ('''error invoking Qt4 moc!

use the MOC environment variable to specify the Qt4 moc command''')
  except CompileError:
    error ('error compiling Qt4 application!')
  except OSError:
    error ('Unexpected error! Unable to configure Qt4 environment')




  report ('Checking for OpenGL: ')
  try:
    gl_test = compile ('''
#include <QtGui>
#include <QtOpenGL>
#include <QApplication>
#include <QGLWidget>
#include <iostream>

class GLWidget : public QGLWidget {
  public:
    GLWidget (QWidget *parent = 0) : QGLWidget (parent) { }
    ~GLWidget() { }
  protected:
    void initializeGL () { 
      std::cout << glGetString (GL_VERSION) << "\\n";
      exit (0); 
    }

    void paintGL () { }
    void resizeGL (int width, int height) { }
};

int main (int argc, char *argv[]) {
  QApplication app (argc, argv);
  GLWidget window;
  window.show();
  return app.exec();
}
''', cpp_flags + qt_cflags, ld_flags + qt_ldflags)
    report (gl_test.strip() + '\n')
    if 'NOT SUPPORTED' in gl_test:
      report ('''
WARNING: not all required OpenGL extensions are supported (see above).
         Some of the graphical user interface components may not be stable on
         this system.
''')
  except:
    error ('OpenGL implementation not found!')







# add debugging or profiling flags if requested:

if profile:
  cpp_flags += [ '-g', '-pg', '-DNDEBUG' ]
  ld_flags += [ '-g', '-pg' ]
  ld_lib_flags += [ '-g', '-pg' ]
elif debug:
  cpp_flags += [ '-O0', '-g', '-D_GLIBCXX_DEBUG=1', '-D_GLIBCXX_DEBUG_PEDANTIC=1' ]
  ld_flags += [ '-g' ]
  ld_lib_flags += [ '-g' ]
else:
  cpp_flags += [ '-O2', '-DNDEBUG' ]




# set flags for static build if required:
if static:
  ld_flags = [ '-static' ] + zlib_ldflags + gsl_ldflags + thread_ldflags




# write out configuration:

cache_filename = os.path.join (os.path.dirname(sys.argv[0]), 'config.' + profile_name)

sys.stdout.write ('\nwriting configuration to file \'' + cache_filename + '\': ')

cache = open (cache_filename, 'w')

cache.write ("""#!/usr/bin/python
#
# autogenerated by MRtrix configure script
#
# configure output:
""")
for line in config_report.splitlines():
  cache.write ('# ' + line + '\n')
cache.write ('\n\n')

commit ('obj_suffix', obj_suffix)
commit ('exe_suffix', exe_suffix)
commit ('lib_prefix', lib_prefix)
commit ('lib_suffix', lib_suffix)
commit ('cpp', cpp);
commit ('cpp_flags', cpp_flags);
commit ('ld', ld);
commit ('ld_flags', ld_flags);
cache.write ('ld_enabled = ')
if noshared:
  cache.write ('False\n')
else:
  cache.write ('True\n')
  commit ('ld_lib', ld_lib);
  commit ('ld_lib_flags', ld_lib_flags);
commit ('thread_cflags', thread_cflags)
commit ('thread_ldflags', thread_ldflags)
commit ('gsl_cflags', gsl_cflags)
commit ('gsl_ldflags', gsl_ldflags)
commit ('qt_cflags', qt_cflags)
commit ('qt_ldflags', qt_ldflags)

cache.close()
sys.stdout.write ('ok\n\n')

